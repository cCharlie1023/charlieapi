(window.webpackJsonp=window.webpackJsonp||[]).push([[19],{334:function(_,i,t){"use strict";t.r(i);var s=t(7),e=Object(s.a)({},(function(){var _=this,i=_._self._c;return i("ContentSlotsDistributor",{attrs:{"slot-key":_.$parent.slotKey}},[i("h2",{attrs:{id:"_2024-3-19"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#_2024-3-19"}},[_._v("#")]),_._v(" 2024/3/19")]),_._v(" "),i("ol",[i("li",[_._v("项目亮点介绍")]),_._v(" "),i("li",[_._v("针对介绍和简历点提出问题，这里多线程优化没讲明白，忘了叙述分批查询后计算相似度返回top5的实际操作")]),_._v(" "),i("li",[_._v("NIO、IO多路复用\n结合redis线程模型说的")]),_._v(" "),i("li",[_._v("为什么快\n对比win下相对于select说的")]),_._v(" "),i("li",[_._v("排序算法并介绍\n介绍了归并和快排")])]),_._v(" "),i("h2",{attrs:{id:"_2024-3-18"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#_2024-3-18"}},[_._v("#")]),_._v(" 2024-3-18")]),_._v(" "),i("ol",[i("li",[_._v("如何解决重复下单问题？\n使用AOP + 注解的方式，实现防止用户短时间内重复提交请求。具体来说，自定义一个注解，注解中包含一个时间变量，在用户访问到包含这个注解的接口时，使用AOP在接口调用前将访问信息存储到redis中，并设置过期时间。这样短时间内再次访问，会去判断redis中有无访问信息，如果有则视为重复提交，直接抛出异常。")]),_._v(" "),i("li",[_._v("springsecurity相关流程")]),_._v(" "),i("li",[_._v("优惠券抢购优化？\n使用redis中的Zset结构，将抢购信息存储到redis中，后续再将数据异步的持久化到数据库中。这样可以使用ZSet的分数来保证抢购顺序，也可以保证唯一抢购。，，，，")]),_._v(" "),i("li",[_._v("Spring的Bean加载流程？")]),_._v(" "),i("li",[_._v("Spring IOC是怎么做到创建一个bean时先完成依赖bean的加载的  ？")]),_._v(" "),i("li",[_._v("HashMap")]),_._v(" "),i("li",[_._v("spring是怎么调用到具体的bean的，比如一个接口有多个实现类型的bean （ 父类的引用时怎么调子类方法的 ）\n当程序执行到一个方法调用时，JVM会查看对象的实际类型（而不是引用类型），然后找到这个类型中对应的方法并执行。")]),_._v(" "),i("li",[_._v("GC流程")])])])}),[],!1,null,null,null);i.default=e.exports}}]);